练习4.1:表达式5+10*20/2的求值结果是多少？
答：105

练习4.2:根据4.12节中的表，在下述表达式的合理位置添加括号，使得添加括号后运算对象的组合顺序与添加括号前一致。
(a) *vec.begin()		(b) *vec.begin() + 1
答：
(a) *(vec.begin())		(b) (*(vec.begin())) + 1

练习4.3:C++语言没有明确规定大多数二元运算符的求值顺序，给编译器优化留下了余地。这种策略实际上实在代码生成效率和程序潜在缺陷之间进行了权衡，你认为这可以接受吗？请说出你的理由。
答：可以接受，C++标准委员会应该只公布其标准，把其它实现的细节交给下面的编译器去实现，若C++语言把所有的细节都照顾到，那么存在不同的编译器又有什么意义呢？(个人理解，还请指正)。

练习4.4:在下面的表达式中添加括号，说明其求值的过程及最终结果，编写程序编译该(不加括号)表达式并输出其结果验证之前的推断。
12 / 3 * 4 + 5 * 15 + 21 % 4 / 2
答：((12 / 3) * 4) + (5 * 15) + ((21 % 4) / 2)

练习4.5:写出下列表达式的求值结果。
(a)-30 * 3 + 21 / 5	(b)-30 + 3 * 21 / 5
(c)30 / 3 * 21 % 5	(d)-30 / 3 * 21 % 4
答：
(a)-86
(b)-18
(c)0
(d)-2

练习4.6:写出一条表达式用于确定一个整数是奇数还是偶数。
答：m % 2

练习4.7:溢出是何含义？写出三条将导致溢出的表达式。
答：当计算结果超出该类型所能表示的范围时就会产生溢出。
INT_MAX + 1;LONG_MAX + 1;ULONG_MAX + 1;
注：必须包含头文件climits。参考：http://www.cplusplus.com/reference/climits/

练习4.8:说明在逻辑与、逻辑或及相等性运算符中运算对象的求值顺序。
答：
逻辑与：当且仅当左侧运算对象为真时才对右侧运算对象求值。
逻辑或：当且仅当左侧运算对象为假时才对右侧运算对象求值。
相等性运算符：满足左结合律，按照从左向右的顺序求值。

练习4.9:解释在下面的if语句中条件部分的判断过程。
 const char *cp = "Hello World";
 if(cp && * cp)
答：首先判断指针cp是否为空指针，当指针cp不为空的时候再判断cp所指向的对象的第一个字符是否为空。

练习4.10:为while循环写一个条件，使其从标准输入中读取整数，遇到42时停止。
答：
int num;
while(cin >> num && num != 42)

练习4.11:书写一条表达式用于测试4个值a、b、c、d的关系，确保a大于b、b大于c、c大于d。
if(a > b && b > c && c > d)

练习4.12:假设i、j和k是三个整数，说明表达式i != j < k的含义。
答：查表4.12可知，"<"运算符的优先级高于"!="运算符。所以该表达式的含义是：先判断j < k，然后再与i进行运算，等价与(i != (j < k))。

练习4.13:在下述语句中，当赋值完成后i和d的值分别是多少？
 int i; double d;
 (a)d = i = 3.5;	(b)i = d = 3.5
答：
(a)i = 3, d = 3
(b)i = 3, d = 3.5

练习4.14:执行下述if语句后将发生什么情况？
 if(42 = i) // ...
 if(i = 42) // ...
答：第一条语句将会产生编译错误，赋值运算符的左侧运算对象必须是一个可修改的左值，而字面值是右值。
第二条语句判断正确，接着执行if语句后面的语句。

练习4.15:下面的赋值是非法的，为什么？应该如何修改？
 double dval; int ival; int *pi;
 dval = ival = pi = 0;
答：对于多重赋值语句中的每一个对象，它的类型或者与右边对象的类型相同、或者可由右边对象的类型转换得到。pi和ival的类型不同，但是pi的类型(int*)无法转换成ival的类型(int)，所以尽管0这个值能赋给任何对象，但是该赋值语句仍然是非法的。应修改为dval = ival = *pi = 0。

练习4.16:尽管下面的语句合法，但它们实际执行的行为可能和预期并不一样，为什么？应该如何修改？
 (a)if(p = getPtr() != 0)	(b)if(i = 1024)
答：
(a)赋值运算符的优先级低于关系运算符的优先级，所以在条件语句中，赋值运算符部分通常应该加上括号。应修改为if((p = getPtr()) != 0)
(b)C++语言允许用赋值运算作为条件，但是这一特性可能带来意想不到的后果。该if语句把字面值1024赋给了i，然后检查赋值的结果是否为真。如果i不为0,则条件为真。应修改为if(i == 1024)。

练习4.17:说明前置递增运算符和后置递增运算符的区别。
答：前置版本将对象本身作为左值返回，后置版本则将对象原始值的副本作为右值返回。

练习4.18:如果第132页那个输出vector对象元素的while循环使用前置递增运算符，将得到什么结果？
答：解引用该值将产生错误的结果。不但无法正确输出第一个元素，而且更糟糕的是如果序列中没有负值，程序将可能试图解引用一个根本不存在的元素。

练习4.19:假设ptr的类型是指向int的指针、vec的类型是vector<int>、ival的类型是int，说明下面的表达式是何含义？如果有表达式不正确，为什么？应该如何修改？
 (a)ptr != 0 && *ptr++	(b)ival++ && ival
 (c)vec[ival++] <= vec[ival]
答：
(a)判断ptr是否为空指针，若不为空指针，再判断ptr所指向的值是否为0,然后将ptr指向下一位置。
(b)判断ival是否为0,然后把ival的值加1,若ival的值不为0,再判断加1后的值是否为0。
(c)vec[ival]的值和vec[ival+1]的值的大小，等价与vec[ival] <= vec[ival+1]
感觉条件不足，无法判断表达式正确与否。




